"""
Vulnerability scanner module for the AI Code Translator.
"""

import re
from typing import List, Dict, Any, Optional
from enum import Enum
from .vulnerability import Vulnerability, Severity, Confidence
import os
import json


class VulnerabilityScannerInterface:
    """Interface for vulnerability scanners."""
    
    async def scan_code(self, code: str, language: str) -> List[Vulnerability]:
        """Scan code for vulnerabilities.
        
        Args:
            code: Code to scan
            language: Programming language
            
        Returns:
            List of detected vulnerabilities
        """
        raise NotImplementedError("This method must be implemented by subclasses")

    def get_patterns(self, language: str) -> List[Dict[str, Any]]:
        """Get patterns for a specific language.
        
        Args:
            language: Programming language
            
        Returns:
            List of patterns
        """
        raise NotImplementedError("This method must be implemented by subclasses")

    def add_pattern(self, language: str, pattern: Dict[str, Any]) -> bool:
        """Add a new pattern for a specific language.
        
        Args:
            language: Programming language
            pattern: Pattern configuration
            
        Returns:
            True if pattern was added, False otherwise
        """
        raise NotImplementedError("This method must be implemented by subclasses")

    def remove_pattern(self, language: str, pattern_id: str) -> bool:
        """Remove a pattern by ID.
        
        Args:
            language: Programming language
            pattern_id: Pattern ID
            
        Returns:
            True if pattern was removed, False otherwise
        """
        raise NotImplementedError("This method must be implemented by subclasses")

    def update_pattern(self, language: str, pattern_id: str, new_pattern: Dict[str, Any]) -> bool:
        """Update an existing pattern.
        
        Args:
            language: Programming language
            pattern_id: Pattern ID
            new_pattern: New pattern configuration
            
        Returns:
            True if pattern was updated, False otherwise
        """
        raise NotImplementedError("This method must be implemented by subclasses")


class VulnerabilityScanner(VulnerabilityScannerInterface):
    """Scans code for potential vulnerabilities."""
    
    def __init__(self, patterns_dir: str = "patterns"):
        """Initialize the vulnerability scanner.
        
        Args:
            patterns_dir: Directory containing vulnerability patterns
        """
        self.patterns_dir = patterns_dir
        self.patterns = {}
        self.load_patterns()
        
    def load_patterns(self):
        """Load vulnerability patterns from files."""
        try:
            # Load patterns for different languages
            pattern_files = {
                "python": "python_patterns.json",
                "javascript": "javascript_patterns.json",
                "java": "java_patterns.json",
                "cpp": "cpp_patterns.json",
                "php": "php_patterns.json"
            }
            
            # Look for patterns in the security/patterns directory
            base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
            patterns_dir = os.path.join(base_dir, 'security', 'patterns')
            
            print(f"Looking for pattern files in: {patterns_dir}")
            
            for lang, filename in pattern_files.items():
                filepath = os.path.join(patterns_dir, filename)
                try:
                    if os.path.exists(filepath):
                        with open(filepath, 'r') as f:
                            self.patterns[lang] = json.load(f)
                            print(f"Loaded {len(self.patterns[lang])} patterns for {lang} from {filename}")
                    else:
                        print(f"Warning: Pattern file not found: {filepath}")
                        self.patterns[lang] = []
                except Exception as e:
                    print(f"Error loading patterns for {lang} from {filepath}: {str(e)}")
                    self.patterns[lang] = []
                    
        except Exception as e:
            print(f"Error loading vulnerability patterns: {str(e)}", exc_info=True)
            self.patterns = {}
            
    async def scan_code(self, code: str, language: str) -> List[Vulnerability]:
        """Scan code for vulnerabilities.
        
        Args:
            code: Code to scan
            language: Programming language
            
        Returns:
            List of detected vulnerabilities
        """
        if not code or not language:
            return []
            
        vulnerabilities = []
        
        # Get patterns for the specified language
        patterns = self.patterns.get(language.lower(), [])
        
        # Check each pattern
        for pattern in patterns:
            try:
                # Search for the pattern in the code
                matches = re.finditer(pattern["regex"], code)
                
                for match in matches:
                    vuln = Vulnerability()
                    vuln.category = pattern["category"]
                    vuln.severity = Severity[pattern["severity"]]
                    vuln.confidence = Confidence[pattern["confidence"]]
                    vuln.description = pattern["description"]
                    vuln.code_snippet = match.group(0)
                    vuln.line_number = code.count("\n", 0, match.start()) + 1
                    
                    vulnerabilities.append(vuln)
                    
                    # Log the match
                    print(f"Match found! Line: {vuln.code_snippet}")
                    print(f"Found {vuln.category} vulnerability on line {vuln.line_number}")
                    
            except Exception as e:
                print(f"Error scanning with pattern: {str(e)}")
                continue
                
        return vulnerabilities

    def get_patterns(self, language: str) -> List[Dict[str, Any]]:
        """Get patterns for a specific language.
        
        Args:
            language: Programming language
            
        Returns:
            List of patterns
        """
        return self.patterns.get(language.lower(), [])

    def add_pattern(self, language: str, pattern: Dict[str, Any]) -> bool:
        """Add a new pattern for a specific language.
        
        Args:
            language: Programming language
            pattern: Pattern configuration
            
        Returns:
            True if pattern was added, False otherwise
        """
        try:
            if language not in self.patterns:
                self.patterns[language] = []
                
            self.patterns[language].append(pattern)
            return True
            
        except Exception as e:
            print(f"Error adding pattern: {str(e)}")
            return False

    def remove_pattern(self, language: str, pattern_id: str) -> bool:
        """Remove a pattern by ID.
        
        Args:
            language: Programming language
            pattern_id: Pattern ID
            
        Returns:
            True if pattern was removed, False otherwise
        """
        try:
            if language in self.patterns:
                self.patterns[language] = [
                    p for p in self.patterns[language] 
                    if p.get("id") != pattern_id
                ]
                return True
                
        except Exception as e:
            print(f"Error removing pattern: {str(e)}")
            return False

    def update_pattern(self, language: str, pattern_id: str, new_pattern: Dict[str, Any]) -> bool:
        """Update an existing pattern.
        
        Args:
            language: Programming language
            pattern_id: Pattern ID
            new_pattern: New pattern configuration
            
        Returns:
            True if pattern was updated, False otherwise
        """
        try:
            if language in self.patterns:
                for i, pattern in enumerate(self.patterns[language]):
                    if pattern.get("id") == pattern_id:
                        self.patterns[language][i] = new_pattern
                        return True
                        
        except Exception as e:
            print(f"Error updating pattern: {str(e)}")
            return False
